/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.26                          *
*        Compiled Aug  8 2014, 14:49:54                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "includes.h"
#include "DIALOG.h"
#include "EmWinHZFont.h"//teng
#include "rtc.h"
#include "gui.h"
#include "MessageBoxUser.h"

extern _calendar_obj calendar;
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_FRAMEWIN_0        (GUI_ID_USER + 0x00)
#define ID_BUTTON_0        (GUI_ID_USER + 0x01)
#define ID_BUTTON_1        (GUI_ID_USER + 0x02)
#define ID_DROPDOWN_0        (GUI_ID_USER + 0x03)
#define ID_DROPDOWN_1        (GUI_ID_USER + 0x04)
#define ID_DROPDOWN_2        (GUI_ID_USER + 0x05)
#define ID_TEXT_0        (GUI_ID_USER + 0x06)
#define ID_TEXT_1        (GUI_ID_USER + 0x07)
#define ID_TEXT_2        (GUI_ID_USER + 0x08)
#define ID_TEXT_3        (GUI_ID_USER + 0x09)
#define ID_TEXT_4        (GUI_ID_USER + 0x0A)
#define ID_SPINBOX_0        (GUI_ID_USER + 0x0B)
#define ID_SPINBOX_1        (GUI_ID_USER + 0x0C)
#define ID_SPINBOX_2        (GUI_ID_USER + 0x0D)
#define ID_SPINBOX_3        (GUI_ID_USER + 0x0E)
#define ID_SPINBOX_4        (GUI_ID_USER + 0x0F)
#define ID_SPINBOX_5        (GUI_ID_USER + 0x10)
#define ID_TEXT_5        (GUI_ID_USER + 0x11)

// USER START (Optionally insert additional defines)
WM_HTIMER hTimer;

static const char * _apMonths[] = {
  "一月",
  "二月",
  "三月",
  "四月",
  "五月",
  "六月",
  "七月",
  "八月",
  "九月",
  "十月",
  "十一月",
  "十二月",
};

static const char * _apDays[] = {
  "日",
  "六",
  "一",
  "二",
  "三",
  "四",
  "五",
};

// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

void drawTimeClock(WM_MESSAGE * pMsg, int fromTimer) {
    const u8 txt[4] = {3, 6, 9, 12};
    int index;
    int rx=37;// X坐标 120
    int ry=42;// Y坐标 90
    int r=32;// 半径 70
    float PI = 3.14159265359;
    // 表针
    float ta, txend, tyend;
    char ac[4];
    
//    if (fromTimer) {
//        WM_SelectWindow(pMsg->hWin);
//    }
    
    GUI_AA_SetFactor(3);
    // 加个画小点吧
    GUI_SetPenSize(2);
    GUI_SetColor(0x555555);
    for (index=0;index<60;index++) {
        float a = 360/60*index;
        float tx = (r-3)*cos(a*PI/180);
        float ty = (r-3)*sin(a*PI/180);
//        GUI_DrawPoint(rx+tx, ry+ty);
        GUI_AA_FillCircle(rx+tx, ry+ty, 1);
    }
    // 画刻度
    GUI_SetColor(0x000000);
    for (index=0;index<12;index++) {
        float a = 360/12*index;
        float tox = r*cos(a*PI/180);
        float toy = r*sin(a*PI/180);
        int tr = (index % 3 == 0) ? (r-5) : (r-4);
        float tix = tr*cos(a*PI/180);
        float tiy = tr*sin(a*PI/180);
        (index % 3 == 0) ? GUI_SetPenSize(4) : GUI_SetPenSize(3);
        GUI_AA_DrawLine(rx+tox, ry+toy, rx+tix, ry+tiy);
        if (index%(12/(sizeof(txt)/sizeof(txt[0])))==0) {
            sprintf(ac, "%d", txt[index/3]);
            GUI_SetTextMode(GUI_TM_TRANS);
            GUI_SetTextAlign(GUI_TA_VCENTER|GUI_TA_HCENTER);
            GUI_SetFont(&GUI_Font6x8);
            tix = (r-11)*cos(a*PI/180);
            tiy = (r-11)*sin(a*PI/180);
            GUI_DispStringHCenterAt(ac, rx+tix, ry+tiy);
        }
    }
    // 画外圈
    GUI_SetColor(0x000000);
    GUI_SetPenSize(4);
    GUI_AA_DrawArc(rx, ry, r, r, 0, 360);
    // 画中心点
    GUI_SetColor(0x0000FF);
    GUI_AA_FillCircle(rx, ry, 4);
    GUI_SetPenSize(3);
    // 显示日期
    sprintf(ac, "%02d/%02d", calendar.w_month, calendar.w_date);
    GUI_SetTextMode(GUI_TM_TRANS);
    GUI_SetTextAlign(GUI_TA_VCENTER|GUI_TA_HCENTER);
    GUI_SetFont(&GUI_FontHZ12);
    GUI_SetColor(0x00AA00);
    GUI_DispStringHCenterAt(ac, rx, ry+r/2);
    // 画时针
    GUI_SetColor(0xFF00FF);
    ta = 360/12*calendar.hour;
    ta += (360/12.0f*(calendar.min/60.0f));// 加上分钟走过的度数
    ta -= 90;
    txend = (r*0.42)*cos(ta*PI/180);
    tyend = (r*0.42)*sin(ta*PI/180);
    GUI_AA_DrawLine(rx, ry, rx+txend, ry+tyend);
    // 画分针
    GUI_SetColor(0x808000);
    ta = 360/60*calendar.min;
    ta -= 90;
    txend = (r*0.6)*cos(ta*PI/180);
    tyend = (r*0.6)*sin(ta*PI/180);
    GUI_AA_DrawLine(rx, ry, rx+txend, ry+tyend);
    // 画秒针
    GUI_SetColor(0xFF0000);
    ta = 360/60*calendar.sec;
    ta -= 90;
    txend = (r*0.75)*cos(ta*PI/180);
    tyend = (r*0.75)*sin(ta*PI/180);
    GUI_AA_DrawLine(rx, ry, rx+txend, ry+tyend);
    
    GUI_AA_SetFactor(0);
//    printf("drawTimeClock\r\n");
}

// USER START (Optionally insert additional static data)
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { FRAMEWIN_CreateIndirect, "时间与日期", ID_FRAMEWIN_0, 0, 0, 240, 320, 0, 0x0, 0 },
//  { BUTTON_CreateIndirect, "取消", ID_BUTTON_0, 20, 270, 80, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "确定", ID_BUTTON_1, 80, 270, 80, 20, 0, 0x0, 0 },
  { SPINBOX_CreateIndirect, "Dropdown", ID_SPINBOX_3, 5, 235, 55, 20, 0, 0x0, 0 },
  { SPINBOX_CreateIndirect, "Dropdown", ID_SPINBOX_4, 80, 235, 55, 20, 0, 0x0, 0 },
  { SPINBOX_CreateIndirect, "Dropdown", ID_SPINBOX_5, 155, 235, 55, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "年", ID_TEXT_0, 65, 237, 20, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "月", ID_TEXT_1, 140, 237, 20, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "日", ID_TEXT_2, 215, 237, 20, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, ":", ID_TEXT_3, 75, 208, 25, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, ":", ID_TEXT_4, 153, 208, 26, 20, 0, 0x0, 0 },
  { SPINBOX_CreateIndirect, "Spinbox", ID_SPINBOX_0, 15, 205, 50, 20, 0, 0x0, 0 },
  { SPINBOX_CreateIndirect, "Spinbox", ID_SPINBOX_1, 90, 205, 55, 20, 0, 0x0, 0 },
  { SPINBOX_CreateIndirect, "Spinbox", ID_SPINBOX_2, 165, 205, 55, 20, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  { TEXT_CreateIndirect, "00:00:00", ID_TEXT_5, 15, 85, 50, 12, 0, 0x0, 0 },
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  int NCode;
  int Id;
  // USER START (Optionally insert additional variables)
  WM_HWIN hItem;
  GUI_RECT Rect;
  CALENDAR_DATE Date;
  // USER END
  int i;
  char text_buffer[20]={0};
  const u8 mon_table[12]={31,28,31,30,31,30,31,31,30,31,30,31};
  int year, month, day, hour, min, sec;
  GUI_RECT clockRect = {5, 22, 65, 65};//{50, 20, 140, 140}
  
  switch (pMsg->MsgId) {
      case WM_INIT_DIALOG:
        hItem = pMsg->hWin;
//        FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
        FRAMEWIN_SetTitleHeight(hItem, 20);
        FRAMEWIN_SetFont(hItem, &GUI_FontHZ16);
        FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
        FRAMEWIN_AddCloseButton(hItem,FRAMEWIN_BUTTON_RIGHT,0);
      
        hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
        BUTTON_SetFont(hItem, &GUI_FontHZ12);
        hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
        BUTTON_SetFont(hItem, &GUI_FontHZ12);
        hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_3);
        SPINBOX_SetFont(hItem, &GUI_FontHZ12);
//        sprintf(text_buffer,"%02d:%02d:%02d",calendar.hour,calendar.min,calendar.sec);  //teng
        SPINBOX_SetRange(hItem, 1970, 2099);
        SPINBOX_SetValue(hItem, calendar.w_year);
        hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_4);
        SPINBOX_SetFont(hItem, &GUI_FontHZ12);
        SPINBOX_SetRange(hItem, 1, 12);
        SPINBOX_SetValue(hItem, calendar.w_month);
        hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_5);
        SPINBOX_SetFont(hItem, &GUI_FontHZ12);
        SPINBOX_SetRange(hItem, 1, mon_table[calendar.w_month]);
        if (calendar.w_month==1 && !Is_Leap_Year(calendar.w_year)) {
            SPINBOX_SetRange(hItem, 1, 29);
        }
        SPINBOX_SetValue(hItem, calendar.w_date);
        hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
        TEXT_SetFont(hItem, &GUI_FontHZ12);
        hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_1);
        TEXT_SetFont(hItem, &GUI_FontHZ12);      
        hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_2);
        TEXT_SetFont(hItem, &GUI_FontHZ12);
        hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_3);
        TEXT_SetFont(hItem, &GUI_FontHZ12);
        hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_4);
        TEXT_SetFont(hItem, &GUI_FontHZ12);
        hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_0);
        SPINBOX_SetFont(hItem, &GUI_FontHZ12);
        SPINBOX_SetRange(hItem, 1, 24);
        SPINBOX_SetValue(hItem, calendar.hour);
        hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_1);
        SPINBOX_SetFont(hItem, &GUI_FontHZ12);
        SPINBOX_SetRange(hItem, 1, 60);
        SPINBOX_SetValue(hItem, calendar.min);
        hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_2);
        SPINBOX_SetFont(hItem, &GUI_FontHZ12);
        SPINBOX_SetRange(hItem, 1, 60);
        SPINBOX_SetValue(hItem, calendar.sec);
        
        hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_5);
        TEXT_SetFont(hItem, &GUI_FontHZ12);
        TEXT_SetTextColor(hItem, 0xFF0000);
        TEXT_SetTextAlign(hItem, GUI_TA_VCENTER|GUI_TA_HCENTER);
        sprintf(text_buffer,"%02d:%02d:%02d",calendar.hour,calendar.min,calendar.sec);  //teng
        TEXT_SetText(hItem, text_buffer);
        
        CALENDAR_SetDefaultDays(_apDays);
        CALENDAR_SetDefaultMonths(_apMonths);
//        CALENDAR_SetDefaultBkColor(CALENDAR_CI_WEEKEND, GUI_GRAY);
//        CALENDAR_SetDefaultBkColor(CALENDAR_CI_WEEKDAY, GUI_LIGHTGRAY);
//        CALENDAR_SetDefaultColor(CALENDAR_CI_WEEKDAY, GUI_WHITE);
//        CALENDAR_SetDefaultColor(CALENDAR_CI_WEEKEND, GUI_GRAY);
//        CALENDAR_SetDefaultColor(CALENDAR_CI_LABEL, GUI_LIGHTBLUE);
        CALENDAR_SetDefaultSize(CALENDAR_SI_CELL_X, 22);
        CALENDAR_SetDefaultSize(CALENDAR_SI_CELL_Y, 14);
        CALENDAR_SetDefaultSize(CALENDAR_SI_HEADER, 23);
        CALENDAR_SetDefaultFont(CALENDAR_FI_CONTENT, &GUI_FontHZ12);
        CALENDAR_SetDefaultFont(CALENDAR_FI_HEADER, &GUI_FontHZ12);
        hItem = CALENDAR_Create(pMsg->hWin, 81, 23, 
                (int)calendar.w_year, (int)calendar.w_month, (int)calendar.w_date, 
                    1, GUI_ID_CALENDAR0, WM_CF_HASTRANS);
        WM_GetWindowRectEx(hItem, &Rect);
        WM_SetHasTrans(hItem);
        
      break;
      case WM_DELETE:
          WM_DeleteTimer(hTimer);
          hTimer=0;
      break;
      case WM_PAINT:
//          printf("wm_paint\r\n");
          drawTimeClock(pMsg, 0);// 画表盘
          if (hTimer==0) {
//              printf("createTimer()\r\n");
              hTimer = WM_CreateTimer(pMsg->hWin, 1, 900, 0);
          }
//          WM_RestartTimer(pMsg->Data.v, 1000);
      break;
      case WM_TIMER:
//          printf("wm_timer\r\n");
//          WM_InvalidateArea(&clockRect);// 5.26试了一天，目前只找到这个方法才能刷新
//          WM_InvalidateWindow(WM_GetActiveWindow());
          WM_InvalidateRect(pMsg->hWin, &clockRect);// 5.32
//          WM_SendMessageNoPara(WM_GetActiveWindow(), WM_PAINT);
//          drawTimeClock(pMsg, 1);// 画表盘
          hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_5);
          sprintf(text_buffer,"%02d:%02d:%02d",calendar.hour,calendar.min,calendar.sec);
          TEXT_SetText(hItem, text_buffer);
      
          WM_RestartTimer(pMsg->Data.v, 900);
      break;
      case WM_NOTIFY_PARENT:
        Id    = WM_GetId(pMsg->hWinSrc);
        NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_0: // Notifications sent by 'Button'
          switch(NCode) {
          case WM_NOTIFICATION_CLICKED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_RELEASED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          // USER START (Optionally insert additional code for further notification handling)
          // USER END
          }
          break;
        case ID_BUTTON_1: // Notifications sent by 'Button'
          switch(NCode) {
          case WM_NOTIFICATION_CLICKED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_RELEASED:
            // USER START (Optionally insert code for reacting on notification message)
            hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_0);// 时
            hour = SPINBOX_GetValue(hItem);
            hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_1);// 分
            min = SPINBOX_GetValue(hItem);
            hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_2);// 秒
            sec = SPINBOX_GetValue(hItem);
            hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_3);// 年
            year = SPINBOX_GetValue(hItem);
            hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_4);// 月
            month = SPINBOX_GetValue(hItem);
            hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_5);// 日
            day = SPINBOX_GetValue(hItem);
            sec = RTC_Set(year, month, day, hour, min, sec);
            hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_CALENDAR0);
            CALENDAR_GetSel(hItem, &Date);
            Date.Year = year;
            Date.Month = month;
            Date.Day = day;
            CALENDAR_SetDate(hItem, &Date);
            CALENDAR_SetSel(hItem, &Date);
            if (sec==0) {
                MESSAGEBOX_Create_User_Modal("成功", "提示");
            } else {
                MESSAGEBOX_Create_User_Modal("失败", "提示");
            }
            // USER END
            break;
          // USER START (Optionally insert additional code for further notification handling)
          // USER END
          }
          break;
        case ID_DROPDOWN_0: // Notifications sent by 'Dropdown'
          switch(NCode) {
          case WM_NOTIFICATION_CLICKED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_RELEASED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_SEL_CHANGED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          // USER START (Optionally insert additional code for further notification handling)
          // USER END
          }
          break;
        case ID_DROPDOWN_1: // Notifications sent by 'Dropdown'
          switch(NCode) {
          case WM_NOTIFICATION_CLICKED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_RELEASED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_SEL_CHANGED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          // USER START (Optionally insert additional code for further notification handling)
          // USER END
          }
          break;
        case ID_DROPDOWN_2: // Notifications sent by 'Dropdown'
          switch(NCode) {
          case WM_NOTIFICATION_CLICKED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_RELEASED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_SEL_CHANGED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          // USER START (Optionally insert additional code for further notification handling)
          // USER END
          }
          break;
        case ID_SPINBOX_0: // Notifications sent by 'Spinbox'
          switch(NCode) {
          case WM_NOTIFICATION_CLICKED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_RELEASED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_MOVED_OUT:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_VALUE_CHANGED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          // USER START (Optionally insert additional code for further notification handling)
          // USER END
          }
          break;
        case ID_SPINBOX_1: // Notifications sent by 'Spinbox'
          switch(NCode) {
          case WM_NOTIFICATION_CLICKED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_RELEASED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_MOVED_OUT:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_VALUE_CHANGED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          // USER START (Optionally insert additional code for further notification handling)
          // USER END
          }
          break;
        case ID_SPINBOX_2: // Notifications sent by 'Spinbox'
          switch(NCode) {
          case WM_NOTIFICATION_CLICKED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_RELEASED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_MOVED_OUT:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_VALUE_CHANGED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          // USER START (Optionally insert additional code for further notification handling)
          // USER END
          }
          break;
        // USER START (Optionally insert additional code for further Ids)
        // USER END
        }
        break;
      // USER START (Optionally insert additional message handling)
      // USER END
      default:
        WM_DefaultProc(pMsg);
        break;
      }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateFramewin
*/
WM_HWIN CreateSetDateTime(void);
WM_HWIN CreateSetDateTime(void) {
    WM_HWIN hWin;
    hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
    return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
